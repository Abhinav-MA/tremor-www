(self.webpackChunknew_tremor_website=self.webpackChunknew_tremor_website||[]).push([[9628],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return c},kt:function(){return h}});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),h=i,m=u["".concat(s,".").concat(h)]||u[h]||d[h]||a;return n?r.createElement(m,o(o({ref:t},c),{},{components:n})):r.createElement(m,o({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var p=2;p<a;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5363:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return c},default:function(){return u}});var r=n(2122),i=n(9756),a=(n(7294),n(3905)),o=["components"],l={},s=void 0,p={type:"mdx",permalink:"/tremor-new-website/0012-correlation",source:"@site/src/pages/0012-correlation.md"},c=[{value:"Summary",id:"summary",children:[]},{value:"Motivation",id:"motivation",children:[]},{value:"Guide-level Explanation",id:"guide-level-explanation",children:[]},{value:"Reference-level Explanation",id:"reference-level-explanation",children:[]},{value:"Drawbacks",id:"drawbacks",children:[]},{value:"Rationale and Alternatives",id:"rationale-and-alternatives",children:[]},{value:"Unresolved Questions",id:"unresolved-questions",children:[]},{value:"Future Possibilities",id:"future-possibilities",children:[]}],d={toc:c};function u(e){var t=e.components,n=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Feature Name: ",(0,a.kt)("inlineCode",{parentName:"li"},"correlation_linked_transport")),(0,a.kt)("li",{parentName:"ul"},"Start Date: 2021-03-12"),(0,a.kt)("li",{parentName:"ul"},"Tremor Issue: ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/tremor-rs/tremor-runtime/issues/0000"},"tremor-rs/tremor-runtime#0000")),(0,a.kt)("li",{parentName:"ul"},"RFC PR: ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/tremor-rs/tremor-rfcs/pull/0000"},"tremor-rs/tremor-rfcs#0000"))),(0,a.kt)("h2",{id:"summary"},"Summary"),(0,a.kt)("p",null,"Linked Transports enable integrating request-response-based communications with Tremor event-streams. Events coming from pipelines can be turned into requests and responses are turned into events, and sent on to other pipelines. Nonetheless, we currently can't correlate them, that is, have request event data present in the context of the response event handling. This RFC is suggesting new means for convenient correlating of events, i.e. the special ",(0,a.kt)("inlineCode",{parentName:"p"},"$correlation")," metadata key."),(0,a.kt)("h2",{id:"motivation"},"Motivation"),(0,a.kt)("p",null,"When we introduced ",(0,a.kt)("a",{parentName:"p",href:"0003-linked-transports/"},"Linked Transport"),", we enabled request-response communication patterns with the outside world, like, HTTP or some Websocket protocols. Right now, request and response handling need to either be done in two different pipelines or in the same and be dispatched within the trickle/tremor-script logic. If any part of the request event needs to be around for response handling, the only option is to handle both in 1 pipeline and use the ",(0,a.kt)("inlineCode",{parentName:"p"},"state")," mechanism to store and retrieve the request event data upon response handling."),(0,a.kt)("p",null,"We are currently adding some correlation data e.g. for the ",(0,a.kt)("inlineCode",{parentName:"p"},"elastic")," offramp, where we store the whole origin ",(0,a.kt)("inlineCode",{parentName:"p"},"event_id"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"origin_uri")," and the ",(0,a.kt)("inlineCode",{parentName:"p"},"payload")," of the document indexed. Or, the ",(0,a.kt)("inlineCode",{parentName:"p"},"rest")," offramp, where we include the HTTP request metadata into the response event. Those are in no means complete, in that, we can only correlate metadata that is also being sent to as the event itself (HTTP headers, elastic document payload). We want the correlation mechanism to be more flexible, and to not affect the actual event payload or outgoing protocol unit. Correlation should be an internal mechanism to your Tremor application logic."),(0,a.kt)("h2",{id:"guide-level-explanation"},"Guide-level Explanation"),(0,a.kt)("p",null,"Every Linked Transport onramp or offramp will for every incoming event take the ",(0,a.kt)("inlineCode",{parentName:"p"},"Value")," at the metadata key ",(0,a.kt)("inlineCode",{parentName:"p"},"$correlation"),", if any, and inject it into the response event metadata under the same key."),(0,a.kt)("p",null,"This way, users can pass correlation data from request to response without the need to manipulate the event payload, and thus, the application data to be sent out. Also, we only need to keep as much correlation data around as we have in-flight events, and most of all, we don't require users to write complex and error-prone correlation logic in tremor-script, which will blow up code bases, possibly beyond reasonable maintainability."),(0,a.kt)("p",null,"Usage example using the ",(0,a.kt)("inlineCode",{parentName:"p"},"rest")," offramp:"),(0,a.kt)("p",null,"Here, we have the request handling pipeline, that moves some event field into the special ",(0,a.kt)("inlineCode",{parentName:"p"},"$correlation")," metadata field:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-trickle"},'# request handling\ndefine script extract_correlation_id\nscript\n    # extract application key and put it into correlation\n    let $correlation = $request.headers["X-Application-Key"] ;\n    event\nend;\n\nselect event from in into extract_correlation_id;\nselect event from extract_correlation_id/out into out;\nselect event from extract_correlation_id/err into err;\n')),(0,a.kt)("p",null,"This is the response handling pipeline which uses the ",(0,a.kt)("inlineCode",{parentName:"p"},"$correlation")," metadata field in further event processing:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-trickle"},'# response handling\ndefine script correlation\nscript\n    # preparation for sending this response further down the road via another rest offramp\n    let $request.headers["X-Application-Key"] = $correlation;\n    let $request.endpoint = "http://example.org/application";\n    event\nend;\n\nselect event from in into correlation;\nselect event from correlation/out into out;\nselect event from correlation/err into err;\n')),(0,a.kt)("p",null,"For cases where the event payload should remain unaffected:"),(0,a.kt)("h2",{id:"reference-level-explanation"},"Reference-level Explanation"),(0,a.kt)("p",null,"As for the implementation, every linked transport needs to be touched and needs to keep around the correlation ",(0,a.kt)("inlineCode",{parentName:"p"},"Value"),"s for each in-flight event, and inject it into the response event."),(0,a.kt)("p",null,"This also includes cleaning up the correlation state in case of errors of the external systems, in case of timeouts and the like, so that we ensure that we never grow beyond the bounds of the configured concurrency."),(0,a.kt)("p",null,"We need to take care that no offramp/onramp uses that field for its own metadata."),(0,a.kt)("h2",{id:"drawbacks"},"Drawbacks"),(0,a.kt)("p",null,"The state we need to keep at the Linked Transport offramp/onramp will grow with the supported concurrency (in-flight requests)."),(0,a.kt)("p",null,"Implementing this will further complicate the already quite complex Linked Transport implementations. Maybe we should consider implementing this as part of the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/tremor-rs/tremor-rfcs/pull/32"},"Connectors RFC"),"."),(0,a.kt)("h2",{id:"rationale-and-alternatives"},"Rationale and Alternatives"),(0,a.kt)("p",null,"In the initial ideas for this RFC, we came up with a ",(0,a.kt)("inlineCode",{parentName:"p"},"correlate"),' operator for "joining" a number of events based on some expression, say, ',(0,a.kt)("inlineCode",{parentName:"p"},"$correlation"),". This was equipped with a ",(0,a.kt)("inlineCode",{parentName:"p"},"timeout"),", so that we take care to not keep too much state around, and put a limit to the correlation window."),(0,a.kt)("p",null,"I decided against coding this as an operator as it can be implemented with core language features of ",(0,a.kt)("inlineCode",{parentName:"p"},"tremor-query"),", with a size-based tumbling window and a group_by:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"define tumbling window size_2\nwith\n  size = 2,\n  eviction_period = 1000\nend;\n\nselect aggr::win::collect_flattened(event) from in[size_2] group by $correlation into out;\n")),(0,a.kt)("p",null,"To get exactly the same timeout behaviour the operator would have, we might need to tweak the current ",(0,a.kt)("inlineCode",{parentName:"p"},"eviction_period")," handling logic, as it currently only gets rid of groups after ",(0,a.kt)("inlineCode",{parentName:"p"},"2 x eviction_period"),". But as the operator can only live in 1 pipeline, we need to pass both events through the same pipeline anyways, and the above code is much more idiomatic and feels more native and less cumbersome."),(0,a.kt)("p",null,"This pattern for correlation will find its way into the docs."),(0,a.kt)("h1",{id:"prior-art"},"Prior Art"),(0,a.kt)("p",null,"Correlating events is a key mechanism for enabling event tracing, which is usually achieved by adding trace ids to events. This is how e.g. ",(0,a.kt)("a",{parentName:"p",href:"https://zipkin.io"},"Zipkin")," tracing works. So, there is a whole ecosystem around enabling observability with proper tracing that relies on those ids being present, and being delivered and maintained across boundaries. While most applications will already include a trace id like this in the event payload, it might still be required to enable keeping those ids while accessing external services via a linked transport. So, this enables better tracing scenarios for Tremor."),(0,a.kt)("h2",{id:"unresolved-questions"},"Unresolved Questions"),(0,a.kt)("p",null,"None."),(0,a.kt)("h2",{id:"future-possibilities"},"Future Possibilities"),(0,a.kt)("p",null,"One road to take this RFC idea down is to bake the correlation and event tracing mechanism even deeper into the runtime.\nWhat we have now with the internal ",(0,a.kt)("inlineCode",{parentName:"p"},"EventId")," is some form of limited tracing, in that, it tracks the minimum and maximum of event ids per source.\nWe could extend this to build causal tracing chains. This is necessary, as at places like a windowed select query, a ",(0,a.kt)("inlineCode",{parentName:"p"},"generic::batch")," operator we emit new events, with a new id. They do keep track of the events that make up the current one, but we cannot properly trace every single event with this mechanism. Such a tracing chain would be usable for the correlation feature, if made accessible to user pipeline code."))}u.isMDXComponent=!0}}]);