"use strict";(self.webpackChunknew_tremor_website=self.webpackChunknew_tremor_website||[]).push([[8643],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return u}});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var m=r.createContext({}),l=function(e){var n=r.useContext(m),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},p=function(e){var n=l(e.components);return r.createElement(m.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,s=e.originalType,m=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=l(t),u=o,g=d["".concat(m,".").concat(u)]||d[u]||c[u]||s;return t?r.createElement(g,a(a({ref:n},p),{},{components:t})):r.createElement(g,a({ref:n},p))}));function u(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var s=t.length,a=new Array(s);a[0]=d;var i={};for(var m in n)hasOwnProperty.call(n,m)&&(i[m]=n[m]);i.originalType=e,i.mdxType="string"==typeof e?e:o,a[1]=i;for(var l=2;l<s;l++)a[l]=t[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},1601:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return i},contentTitle:function(){return m},metadata:function(){return l},toc:function(){return p},default:function(){return d}});var r=t(7462),o=t(3366),s=(t(7294),t(3905)),a=["components"],i={},m="Transient Write-Ahead Log",l={unversionedId:"Workshop/examples/transient_gd/README",id:"Workshop/examples/transient_gd/README",isDocsHomePage:!1,title:"Transient Write-Ahead Log",description:"The write-ahead log builds on circuit breaker and acknowledgement mechanisms to",source:"@site/docs/Workshop/examples/20_transient_gd/README.md",sourceDirName:"Workshop/examples/20_transient_gd",slug:"/Workshop/examples/transient_gd/README",permalink:"/tremor-new-website/docs/Workshop/examples/transient_gd/README",editUrl:"https://github.com/tremor-rs/tremor-new-website/tree/main/docs/Workshop/examples/20_transient_gd/README.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"syslog udp dns",permalink:"/tremor-new-website/docs/Workshop/examples/syslog_udp_dns/README"},next:{title:"Persistent Write-Ahead Log",permalink:"/tremor-new-website/docs/Workshop/examples/persistent_gd/README"}},p=[{value:"Environment",id:"environment",children:[]},{value:"Insights",id:"insights",children:[]}],c={toc:p};function d(e){var n=e.components,t=(0,o.Z)(e,a);return(0,s.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"transient-write-ahead-log"},"Transient Write-Ahead Log"),(0,s.kt)("p",null,"The write-ahead log builds on circuit breaker and acknowledgement mechanisms to\nprovide guaranteed delivery. The write-ahead log is useful in situations\nwhere sources/onramps do not offer guaranteed delivery themselves, but the data being distributed downstream can benefit from protection against loss and duplication."),(0,s.kt)("p",null,"In the configuration in this tutorial we configure a transient in-memory WAL."),(0,s.kt)("h2",{id:"environment"},"Environment"),(0,s.kt)("p",null,"We configure a metronome as a source of data."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-yaml"},"# File: etc/tremor/config/metronome.yaml\nonramp:\n  - id: metronome\n    type: metronome\n    config:\n      interval: 1000 # Every second\n")),(0,s.kt)("p",null,"We configure a straight forward passthrough query to distribute\nthe data to connected downstream sinks."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-trickle"},"# File: etc/tremor/config/transient_gd.trickle\nuse tremor::system;\n\ndefine qos::wal operator in_memory_wal\nwith\n  read_count = 20,\n  max_elements = 1000, # Capacity limit of 1000 stored events\n  max_bytes = 10485760 # Capacity limit of 1MB of events\nend;\n\ncreate operator in_memory_wal;\n\nselect patch event of\n  insert hostname = system::hostname()\nend\nfrom in into in_memory_wal;\n\nselect event from in_memory_wal into out;\n")),(0,s.kt)("p",null,"We then distribute the metronome events downstream to another websocket\nlistener. We use ",(0,s.kt)("inlineCode",{parentName:"p"},"websocat")," for this purpose in this example. We can invoke\nthe server as follows:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"$ websocat -s 8080\nListening on ws://127.0.0.1:8080/\n")),(0,s.kt)("p",null,"We configure the sink/offramp as follows:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-yaml"},"offramp:\n  - id: ws\n    type: ws\n    config:\n      url: ws://localhost:8080/\n")),(0,s.kt)("p",null,"Finally, we interconnect the source, sink and pipeline logic into\nan active flow:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'binding:\n  - id: default\n    links:\n      "/onramp/metronome/{instance}/out": ["/pipeline/main/{instance}/in"]\n      "/pipeline/main/{instance}/out": ["/offramp/ws/{instance}/in"]\n\nmapping:\n  /binding/default/01:\n    instance: "01"\n')),(0,s.kt)("p",null,"Running the example via the tremor client as follows:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"$ tremor server run -f etc/tremor/config/*\n")),(0,s.kt)("h2",{id:"insights"},"Insights"),(0,s.kt)("p",null,"If the tremor process restarts we sequence from the beginning."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'$ websocat -s 8080\nListening on ws://127.0.0.1:8080/\n{"onramp":"metronome","id":0,"hostname":"ALT01827","ingest_ns":1600689100122526000}\n{"onramp":"metronome","id":1,"hostname":"ALT01827","ingest_ns":1600689101122912000}\n{"onramp":"metronome","id":2,"hostname":"ALT01827","ingest_ns":1600689102124688000}\n{"onramp":"metronome","id":0,"hostname":"ALT01827","ingest_ns":1600689104854927000}\n{"onramp":"metronome","id":1,"hostname":"ALT01827","ingest_ns":1600689105855314000}\n{"onramp":"metronome","id":2,"hostname":"ALT01827","ingest_ns":1600689106855645000}\n{"onramp":"metronome","id":3,"hostname":"ALT01827","ingest_ns":1600689107856271000}\n{"onramp":"metronome","id":0,"hostname":"ALT01827","ingest_ns":1600689202887145000}\n{"onramp":"metronome","id":1,"hostname":"ALT01827","ingest_ns":1600689203888395000}\n{"onramp":"metronome","id":2,"hostname":"ALT01827","ingest_ns":1600689204889220000}\n')),(0,s.kt)("p",null,"!!! note\nNotice that we start from sequence ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," 3 times, so we restarted tremor 3 times."),(0,s.kt)("p",null,"If the downstream websocket service restarts we can recover up to 1000 events. We may lose in flight events that were sending at the time the server went down. However, for fast restarts of the downstream service the losses should be minimal."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'$ websocat -s 8080\nListening on ws://127.0.0.1:8080/\n{"onramp":"metronome","id":17,"hostname":"ALT01827","ingest_ns":1600689219933167000}\n{"onramp":"metronome","id":18,"hostname":"ALT01827","ingest_ns":1600689220936343000}\n{"onramp":"metronome","id":19,"hostname":"ALT01827","ingest_ns":1600689221937353000}\n{"onramp":"metronome","id":20,"hostname":"ALT01827","ingest_ns":1600689222942518000}\n{"onramp":"metronome","id":21,"hostname":"ALT01827","ingest_ns":1600689223945736000}\n{"onramp":"metronome","id":22,"hostname":"ALT01827","ingest_ns":1600689224949145000}\n\n$ websocat -s 8080\nListening on ws://127.0.0.1:8080/\n{"onramp":"metronome","id":25,"hostname":"ALT01827","ingest_ns":1600689227960081000}\n{"onramp":"metronome","id":26,"hostname":"ALT01827","ingest_ns":1600689228960247000}\n{"onramp":"metronome","id":27,"hostname":"ALT01827","ingest_ns":1600689229960449000}\n{"onramp":"metronome","id":28,"hostname":"ALT01827","ingest_ns":1600689230962355000}\n{"onramp":"metronome","id":29,"hostname":"ALT01827","ingest_ns":1600689231962934000}\n\n$ websocat -s 8080\nListening on ws://127.0.0.1:8080/\n{"onramp":"metronome","id":31,"hostname":"ALT01827","ingest_ns":1600689233968332000}\n{"onramp":"metronome","id":32,"hostname":"ALT01827","ingest_ns":1600689234973058000}\n{"onramp":"metronome","id":33,"hostname":"ALT01827","ingest_ns":1600689235974217000}\n{"onramp":"metronome","id":34,"hostname":"ALT01827","ingest_ns":1600689236975746000}\n{"onramp":"metronome","id":35,"hostname":"ALT01827","ingest_ns":1600689237976774000}\n{"onramp":"metronome","id":36,"hostname":"ALT01827","ingest_ns":1600689238980380000}\n{"onramp":"metronome","id":37,"hostname":"ALT01827","ingest_ns":1600689239985447000}\n')),(0,s.kt)("p",null,"!!! note\nNote that we recover ",(0,s.kt)("strong",{parentName:"p"},"most")," but now all of the data. As the downstream websocket connection is not a guaranteed delivery connection the recovery and protection against data loss is best effort in this case"),(0,s.kt)("p",null,"In short, the transient in memory wal can assist with partial recovery and\nwill actively reduce data loss within the configured retention but it is\nnot lossless."))}d.isMDXComponent=!0}}]);