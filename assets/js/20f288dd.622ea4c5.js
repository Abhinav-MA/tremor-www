"use strict";(self.webpackChunknew_tremor_website=self.webpackChunknew_tremor_website||[]).push([[5773],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=c(n),d=r,g=m["".concat(l,".").concat(d)]||m[d]||u[d]||i;return n?a.createElement(g,o(o({ref:t},p),{},{components:n})):a.createElement(g,o({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},22416:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},metadata:function(){return l},toc:function(){return c},default:function(){return u}});var a=n(87462),r=n(63366),i=(n(67294),n(3905)),o=["components"],s={},l={unversionedId:"tremor-query/walkthrough",id:"tremor-query/walkthrough",isDocsHomePage:!1,title:"Trickle Walkthough",description:"---",source:"@site/docs/tremor-query/walkthrough.md",sourceDirName:"tremor-query",slug:"/tremor-query/walkthrough",permalink:"/tremor-new-website/docs/tremor-query/walkthrough",editUrl:"https://github.com/tremor-rs/tremor-new-website/tree/main/docs/tremor-query/walkthrough.md",version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Periodic Synthetic Metrics Events",permalink:"/tremor-new-website/docs/tremor-query/recipes"},next:{title:"CNCF Core Infrastructure Initiative",permalink:"/tremor-new-website/docs/governance/CII"}},c=[{value:"Overview",id:"overview",children:[]},{value:"Scripts and Operators",id:"scripts-and-operators",children:[]},{value:"Building Query Graph Algorithms",id:"building-query-graph-algorithms",children:[{value:"Branching",id:"branching",children:[]}]},{value:"Combining",id:"combining",children:[]},{value:"Aggregations",id:"aggregations",children:[]},{value:"Aggregation Mechanics",id:"aggregation-mechanics",children:[{value:"Windowing",id:"windowing",children:[]},{value:"Tilt Frames",id:"tilt-frames",children:[]}]},{value:"Group Mechanics",id:"group-mechanics",children:[{value:"Set based grouping",id:"set-based-grouping",children:[]},{value:"Each based grouping",id:"each-based-grouping",children:[]},{value:"Limitations",id:"limitations",children:[]}]}],p={toc:c};function u(e){var t=e.components,s=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},p,s,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("hr",null),(0,i.kt)("p",null,"In this section we walk through increasingly complex tremor query language ( trickle )\nprogramming examples, introducing key concepts as we progress."),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"Trickle is a near real-time stream-based structured query language that\nbuilds on the tremor scripting language."),(0,i.kt)("p",null,"Trickle queries are compiled in pipeline DAGs and replace the yaml pipeline\nformat used in previous versions to describe event processing graphs in\nthe tremor runtime."),(0,i.kt)("p",null,"The most basic query possible in trickle is"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-trickle"},"select event from in into out; # A basic passthrough query pipeline\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"event")," keyword selects the event from the standard input stream ",(0,i.kt)("inlineCode",{parentName:"p"},"in"),"\nand passes it through unchanged to the standard output stream ",(0,i.kt)("inlineCode",{parentName:"p"},"out"),"."),(0,i.kt)("p",null,"In tremor's trickle query language queries are compiled and optimised and\ndata is streamed though the query. Data can be passed through, transformed,\nfiltered, aggregated, branched or combined to form continuous stream processing\nalgorithms."),(0,i.kt)("p",null,"Like other event processing languages, trickle ",(0,i.kt)("em",{parentName:"p"},"inverts")," the relationship between\nquery and data when compared to normal RDBMS SQL languages. Instead of running a\ndynamic query against static in memory or disk persisted data, we compile and\noptimise queries and stream near real-time data through each query."),(0,i.kt)("p",null,"Data can be ingested from the outside world via the 'in' standard stream.\nData can be produced to the outside world via the 'out' standard stream.\nErrors can be processed through the 'err' standard stream."),(0,i.kt)("p",null,"These three primitives are analogous to the ",(0,i.kt)("inlineCode",{parentName:"p"},"stdin"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"stdout")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"stderr")," streams\nin UNIX-like systems. These can be chained or interconnected via connecting multiple\nstatements together to form a directed acyclic graph."),(0,i.kt)("p",null,"We can branch inputs using ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"having")," clauses as filters to logically\npartition streams into independent processing streams."),(0,i.kt)("p",null,"In the below example we partition events by their ",(0,i.kt)("inlineCode",{parentName:"p"},"seq_num")," field. If the number\nis even, we branch the corresponding events into a stream named ",(0,i.kt)("inlineCode",{parentName:"p"},"evens"),". If the\nnumber is odd, we branch to a stream named ",(0,i.kt)("inlineCode",{parentName:"p"},"odds"),"."),(0,i.kt)("p",null,"The logical inverse of branching is to unify or union streams together, this operation\nis also supported via the select operation and is demonstrated below. We combine\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"evens")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"odds")," streams into the standard output stream"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-trickle"},'# create private intermediate internal streams\ncreate stream evens;\ncreate stream odds;\n\n# branch input into even/odd sequenced events using where clause\nselect { "even": event } from in where (event.seq_num %2 == 1) into evens;\nselect { "odd": event } from in where (event.seq_num %2 == 0) into odds;\n\n# combine / union evens and odds into standard out stream\nselect event from evens into out;\nselect event from odds into out;\n')),(0,i.kt)("p",null,"We can test this with a json event using the ",(0,i.kt)("inlineCode",{parentName:"p"},"tremor")," command line tool"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{ "seq_num": 4, "value": 10, "group": "horse" }\n')),(0,i.kt)("p",null,"Assuming the trickle query is stored in a file called ",(0,i.kt)("inlineCode",{parentName:"p"},"evenodd.trickle")," with the sample event\nin a file called ",(0,i.kt)("inlineCode",{parentName:"p"},"data.json")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ tremor run evenodd.trickle -i data.json\n")),(0,i.kt)("p",null,"The command line tool will inject all events from the file provided by the ",(0,i.kt)("inlineCode",{parentName:"p"},"-i")," argument and we would\nexpect to see output from the tool as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'{"odd": {"seq_num": 4, "value": 10, "group": "horse"}}\n')),(0,i.kt)("h2",{id:"scripts-and-operators"},"Scripts and Operators"),(0,i.kt)("p",null,"Here's the logic for an entire backpressure algorithm that could be introduced as\na proxy between two systems, implemented by using a builtin operator called ",(0,i.kt)("a",{parentName:"p",href:"/tremor-new-website/docs/tremor-query/operators#qosbackpressure"},(0,i.kt)("inlineCode",{parentName:"a"},"qos::backpressure")),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-trickle"},"define qos::backpressure operator bp\nwith\n    timeout = 10000,\n    steps = [ 1, 50, 100, 250, 750 ],\nend;\n\ncreate operator bp from bp;\nselect event from in into bp;\nselect event from bp into out;\n")),(0,i.kt)("p",null,"A slightly more complex example that uses both operators and the tremor scripting language\nwith the query language all together:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tremor"},'define grouper::bucket operator kfc;\n\ndefine script categorize\nscript\n  let $rate = 1;\n  let $class = event.`group`;\n  { "event": event, "rate": $rate, "class": $class };\nend;\n\ncreate operator kfc from kfc;\n\n# where script definition and instance name are the same, we can\n# omit the from clause in operator and script \'create\' statements\ncreate script categorize;\n\n# Stream ingested data into categorize script\nselect event from in into categorize;\n\n# Stream scripted events into kfc bucket operator\nselect event from categorize into kfc;\n\n# Stream bucketed events into out stream\nselect event from kfc into out;\n')),(0,i.kt)("p",null,"Operators are defined as ",(0,i.kt)("inlineCode",{parentName:"p"},"<module>::<name>")," in the\ncontext of an operator definition clause. Operators, like script definitions can take arguments."),(0,i.kt)("p",null,"Definitions in tremor are non-executing. They should be considered as templates or specifications."),(0,i.kt)("p",null,"In the query language, any ",(0,i.kt)("inlineCode",{parentName:"p"},"define")," clause creates specifications, possibly with arguments for\nspecialization. They are typically incarnated via the ",(0,i.kt)("inlineCode",{parentName:"p"},"create")," clause. Anything that is ",(0,i.kt)("inlineCode",{parentName:"p"},"create"),"ed\nwill form a stream or node in the query graph - these ",(0,i.kt)("em",{parentName:"p"},"do")," consume memory and participate in a\npipeline query algorithm."),(0,i.kt)("p",null,"So in the above example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"categorize")," script and the ",(0,i.kt)("inlineCode",{parentName:"p"},"categorize")," node have both a definition\nor specification ",(0,i.kt)("strong",{parentName:"p"},"and")," an instance node that participates in the graph at runtime. It is often\nconvenient to use the same name where there is only one instance of an operator of a given type."),(0,i.kt)("h2",{id:"building-query-graph-algorithms"},"Building Query Graph Algorithms"),(0,i.kt)("p",null,"Data streams can be branched and combined in the trickle query language via\nthe select statement. The resulting graphs must be acyclic with no direct or\nindirect looping cycles."),(0,i.kt)("h3",{id:"branching"},"Branching"),(0,i.kt)("p",null,"Branching data streams to multiple streams is performed via select operations"),(0,i.kt)("p",null,"Branch data into 3 different output stream ports"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tremor"},"select event from in into out/a;\nselect event from in into out/b;\nselect event from in into out/c;\n")),(0,i.kt)("p",null,"Branch data into 3 different intermediate streams"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tremor"},"create stream a;\ncreate stream b;\ncreate stream c;\n\nselect event from in into a;\nselect event from in into b;\nselect event from in into c;\n")),(0,i.kt)("h2",{id:"combining"},"Combining"),(0,i.kt)("p",null,"Multiple data streams can also be combined via select operations."),(0,i.kt)("p",null,"Combine 3 data streams into a single output stream"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tremor"},"...\n\nselect event from a into out;\nselect event from b into out;\nselect event from c into out;\n")),(0,i.kt)("p",null,"Combine 3 data stream ports from 1 or many streams into a single output stream"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tremor"},"...\n\nselect event from a/1 into out;\nselect event from a/2 into out;\nselect event from b into out;\n")),(0,i.kt)("h2",{id:"aggregations"},"Aggregations"),(0,i.kt)("p",null,"A key feature of the tremor query language are aggregations. These are supported with:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Windows - A window is a range of events, clock or data time. There can be many different types of windows."),(0,i.kt)("li",{parentName:"ul"},"Aggregate functions - An aggregate function is a function that runs in the context of a window of events, emitting results intermittently"),(0,i.kt)("li",{parentName:"ul"},"Tilt Frames - A tilt frame is a chain of compatible windows with ",(0,i.kt)("strong",{parentName:"li"},"decreasing")," resolution used to reduce memory pressure and preserve relative accuracy of windowed aggregate functions")),(0,i.kt)("p",null,"An example clock-driven tumbling window:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'define tumbling window `15secs`\nwith\n   interval = core::datetime::with_seconds(15),\nend;\n\nselect {\n    "count": aggr::stats::count(), # Aggregate \'count\' function\n    "min": aggr::stats::min(event.value),\n    "max": aggr::stats::max(event.value),\n    "mean": aggr::stats::mean(event.value),\n    "stdev": aggr::stats::stdev(event.value),\n    "var": aggr::stats::var(event.value),\n}\nfrom in[`15secs`] # We apply the window nominally to streams\ninto out;\n')),(0,i.kt)("p",null,"To use a window we need to define the window specifications, such as a 15 second clock-based\ntumbling window called ",(0,i.kt)("inlineCode",{parentName:"p"},"15secs")," as above. We can then create instances of these windows at runtime by\napplying those windows to streams. This is done in the ",(0,i.kt)("inlineCode",{parentName:"p"},"from")," clause of a ",(0,i.kt)("inlineCode",{parentName:"p"},"select")," statement."),(0,i.kt)("p",null,"Wherever windows are applied, aggregate functions can be used. In the above example, we are calculating\nthe minimum, maximum, average, standard deviation and variance of a ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," numeric field in data streaming\ninto the query via the standard input stream."),(0,i.kt)("p",null,"The query language is not constrained to clock-driven window definitions. Windows can also be\ndata-driven or fully programmatic."),(0,i.kt)("p",null,"A more complete example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tremor"},'select {\n    "measurement": event.measurement,\n    "tags": patch event.tags of insert "window" => window end,\n    "stats": aggr::stats::hdr(event.fields[group[2]], [ "0.5", "0.9", "0.99", "0.999" ]),\n    "class": group[2],\n    "timestamp": aggr::win::first(event.timestamp),\n}\nfrom in[`10secs`, `1min`, `10min`, `1h`]\nwhere event.measurement == "udp_lb_test"\n   or event.measurement == "kafka-proxy.endpoints"\n   or event.measurement == "burrow_group"\n   or event.measurement == "burrow_partition"\n   or event.measurement == "burrow_topic"\ngroup by set(event.measurement, event.tags, each(record::keys(event.fields)))\ninto normalize;\n')),(0,i.kt)("p",null,"In the above example we use a single aggregate function called ",(0,i.kt)("inlineCode",{parentName:"p"},"aggr::stats::hdr")," which uses a high dynamic range\nor HDR Histogram to compute quantile estimates and basic statistics against a number of dynamic grouping fields\nset by the ",(0,i.kt)("inlineCode",{parentName:"p"},"group")," clause. A group clause effectively partitions our operation by the group expressions provided\nby the trickle query programmer. In the example, we're using the field names of the nested 'fields' record on inbound\nevents to compose a component of a group that is also qualified by tags and a measurement name. The field component\nis used as a numeric input to the histogram aggregate function."),(0,i.kt)("p",null,"In the ",(0,i.kt)("inlineCode",{parentName:"p"},"from")," clause, we are using a tilt frame, or a succession of window resolutions over which this aggregate\nfunction is producing results. So a ",(0,i.kt)("inlineCode",{parentName:"p"},"10secs")," window is emitting on a 10-second repeating basis into a ",(0,i.kt)("inlineCode",{parentName:"p"},"1min")," frame.\nSo 6 times per second the state of the 10 second window is merged into the ",(0,i.kt)("inlineCode",{parentName:"p"},"1min")," frame. This merge process is\nperformed for each frame in the tilt frame."),(0,i.kt)("p",null,"The advantage of tilt-frames is that as the target expression is ",(0,i.kt)("strong",{parentName:"p"},"the same")," for each frame, we can ",(0,i.kt)("em",{parentName:"p"},"merge")," across\neach frame without amplifying error - in short, we get the ",(0,i.kt)("strong",{parentName:"p"},"effect")," of summarisation without loss of accuracy."),(0,i.kt)("h2",{id:"aggregation-mechanics"},"Aggregation Mechanics"),(0,i.kt)("p",null,"The mechanics of aggregation in the query language are non-trivial."),(0,i.kt)("p",null,"A high level non-normative summary follows."),(0,i.kt)("h3",{id:"windowing"},"Windowing"),(0,i.kt)("p",null,"Assuming a periodic event delivered every 2 seconds into tremor."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"tumbling-event-windows.png",src:n(13079).Z})),(0,i.kt)("p",null,"A size based window of size 2 would emit a synthetic output event every 2 events.\nSo the lifespan of a size based window is 2 events, repeated and non-overlapping for tumbling style windows.\nIn the illustration above events ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"2")," in the first window ",(0,i.kt)("inlineCode",{parentName:"p"},"w0")," produce a single synthetic or derivate event ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),"\nEvents ",(0,i.kt)("inlineCode",{parentName:"p"},"3")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"4")," in the second window ",(0,i.kt)("inlineCode",{parentName:"p"},"w1")," produce a single synthetic or derivate event ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),"\nAs there is no 6th event in the example illustration, we will ",(0,i.kt)("em",{parentName:"p"},"never")," get another synthetic output event"),(0,i.kt)("p",null,"Contrast this with the 10 second or clock-based tumbling window. In the first window ",(0,i.kt)("inlineCode",{parentName:"p"},"w0"),"s lifetime we capture\nall events in the illustration."),(0,i.kt)("h3",{id:"tilt-frames"},"Tilt Frames"),(0,i.kt)("p",null,"Assuming a continuous flow of events into tremor..."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"tilt-frame-mechanics.png",src:n(13881).Z})),(0,i.kt)("p",null,"All the synthetic outputs of successive 5 minute windows that fit into a 15 minute interval are ",(0,i.kt)("strong",{parentName:"p"},"merged"),"\ninto the 15 minute window. All the outputs of successive 15 minute intervals that fit into a 1 hour interval\nare ",(0,i.kt)("strong",{parentName:"p"},"merged")," into the 1 hour window. By chaining and merging, tremor can optimise ( reduce ) the amount\nof memory required across the chain when compared to multiple independent windows ",(0,i.kt)("inlineCode",{parentName:"p"},"select")," expressions.\nIn the case of aggregate functions like ",(0,i.kt)("inlineCode",{parentName:"p"},"aggr::stats::hdr`` or"),"aggr::stats::dds``` the savings are significant."),(0,i.kt)("p",null,"If we imagine 1M events per second, that is 300M events every 5 minutes. 900M every 15, 3.6B every hour."),(0,i.kt)("p",null,"By using tilt frames we can maximally minimize internal memory consumption, whilst reducing the volume of\nincremental computation ( per event, per frame ), and further whilst preserving relative accuracy for\nmerge-capable aggregate functions."),(0,i.kt)("p",null,"The converged statistics under merge exhibit the same relative accuracy at a fraction of the computational\nand memory overhead without the using the tilt-frame mechanism."),(0,i.kt)("h2",{id:"group-mechanics"},"Group Mechanics"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"group by")," clause in the query language partitions streams before windows and tilt frames\nare applied. Groups can be set-based, each-based or composites thereof."),(0,i.kt)("h3",{id:"set-based-grouping"},"Set based grouping"),(0,i.kt)("p",null,"Grouping by set partitions streams by a concatenation of expressions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tremor"},"select event from in\ngroup by set(event.country, event.region)\ninto out;\n")),(0,i.kt)("p",null,"In the example expression we are partitioning into a composite group that is\ncomposed of the country and region of each inbound event."),(0,i.kt)("p",null,"So we expect data of the following form"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{ "country": "US", "region": "east", "az": "1", ... }\n{ "country": "US", "region": "east", "az": "2", ... }\n')),(0,i.kt)("h3",{id:"each-based-grouping"},"Each based grouping"),(0,i.kt)("p",null,"Given that our data can be nested, however, our data could be structured differently:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "country": "US",\n  regions: {\n    "east": [ "1", "2"],\n  }\n  ...\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tremor"},"select event from in\ngroup by each(record::keys(event.regions))\ninto out;\n")),(0,i.kt)("p",null,"Each field in the nested ",(0,i.kt)("inlineCode",{parentName:"p"},"locations")," field becomes a component of our\nset and qualified by country ..."),(0,i.kt)("h3",{id:"limitations"},"Limitations"),(0,i.kt)("p",null,"There are cases however that are currently complex to partition with a\nsingle select statement due to limitations with the grouping clause. For example\nwhat if we wanted to make availability zones a component of our group partitions?"),(0,i.kt)("p",null,"How would we structure such a query?"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "country": "US",\n  regions: {\n    "east": [ "1", "2"], # AZs by region\n  }\n  ...\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tremor"},'create stream by_country_region;\n\nselect { "country": event.country, "region": group[0], "azs": event.regions[group[0]] }\nfrom in\ngroup by each(record::keys(event.regions))\ninto by_country_region;\n')),(0,i.kt)("p",null,"We can preprocess our inbound stream and collapse our locations\nsub-record a single level by hoisting the ",(0,i.kt)("inlineCode",{parentName:"p"},"region")," field to the\ntop level of a synthetic intermediate outbound stream ",(0,i.kt)("inlineCode",{parentName:"p"},"by_country_region"),"."),(0,i.kt)("p",null,"We can postprocess the intermediate stream ",(0,i.kt)("inlineCode",{parentName:"p"},"by_country_region")," into a\nsingle outbound stream that further extracts and hoists the 'az' dimension"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tremor"},'select { "country": event.country, "region": event.region, "az": group[0], }\nfrom by_country_region\ngroup by each(event.azs)\ninto out;\n')),(0,i.kt)("p",null,"So, we need 2 select statements to compose a solution where there are multiple\nnesting levels via successive extraction of group components. The same principle\nworks with more complex grouping requirements."),(0,i.kt)("p",null,"Once the grouping mechanics are resolved, windowing, aggregation and tilt-frames\ncan be applied to further refine queries."))}u.isMDXComponent=!0},13881:function(e,t,n){t.Z=n.p+"assets/images/tilt-frame-mechanics-ad37cfa0eab92e84ec9838c364ceef1b.png"},13079:function(e,t,n){t.Z=n.p+"assets/images/tumbling-event-windows-0c396bde4a1226bc661003e2bfee0ebd.png"}}]);