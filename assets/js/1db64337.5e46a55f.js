"use strict";(self.webpackChunknew_tremor_website=self.webpackChunknew_tremor_website||[]).push([[1372],{3905:function(e,t,r){r.d(t,{Zo:function(){return d},kt:function(){return u}});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),p=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},d=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(r),u=a,h=c["".concat(l,".").concat(u)]||c[u]||m[u]||o;return r?n.createElement(h,i(i({ref:t},d),{},{components:r})):n.createElement(h,i({ref:t},d))}));function u(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var p=2;p<o;p++)i[p]=r[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}c.displayName="MDXCreateElement"},26777:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return d},default:function(){return c}});var n=r(87462),a=r(63366),o=(r(67294),r(3905)),i=["components"],s={id:"overview",title:"Architecture Overview",sidebar_position:100},l="Overview",p={unversionedId:"overview",id:"overview",isDocsHomePage:!1,title:"Architecture Overview",description:"This page is an overview of the Tremor Project and the model it is built on.",source:"@site/docs/overview.md",sourceDirName:".",slug:"/overview",permalink:"/docs/next/overview",editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/docs/overview.md",tags:[],version:"current",sidebarPosition:100,frontMatter:{id:"overview",title:"Architecture Overview",sidebar_position:100},sidebar:"docsSidebar",previous:{title:"Tremor",permalink:"/docs/next/index"},next:{title:"Constraints and Limitations",permalink:"/docs/next/ConstraintsLimitations"}},d=[{value:"What is Tremor?",id:"what-is-tremor",children:[]},{value:"Functionality",id:"functionality",children:[]},{value:"Tremor URLs",id:"tremor-urls",children:[]},{value:"Runtime Model",id:"runtime-model",children:[]},{value:"Event Ordering",id:"event-ordering",children:[]},{value:"Pipeline Model",id:"pipeline-model",children:[{value:"Data Flow",id:"data-flow",children:[]},{value:"Signal Flow",id:"signal-flow",children:[]},{value:"Contraflow",id:"contraflow",children:[]}]},{value:"Guaranteed Delivery",id:"guaranteed-delivery",children:[]},{value:"Runtime Facilities",id:"runtime-facilities",children:[{value:"Conductors",id:"conductors",children:[]},{value:"Metrics",id:"metrics",children:[]}]},{value:"Data Model",id:"data-model",children:[{value:"Distribution Model",id:"distribution-model",children:[]},{value:"Client/Server",id:"clientserver",children:[]}]}],m={toc:d};function c(e){var t=e.components,s=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,n.Z)({},m,s,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"overview"},"Overview"),(0,o.kt)("p",null,"This page is an overview of the Tremor Project and the model it is built on."),(0,o.kt)("h2",{id:"what-is-tremor"},"What is Tremor?"),(0,o.kt)("p",null,"Tremor is an event processing system designed to process and distribute unstructured data at scale. It primarily supports structural pattern matching, filtering, and transformation of data."),(0,o.kt)("h2",{id:"functionality"},"Functionality"),(0,o.kt)("p",null,"Tremor is designed to handle the following:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Data Bridging - Tremor bridges asynchronous sources with synchronous sinks. Its ability to bridge sync/async and vice-versa enables message flows to be classified, dimensioned, segmented, and routed using user defined logic while handling back-pressure and other distributed systems problems on behalf of its operators."),(0,o.kt)("li",{parentName:"ul"},"Distribution at Scale - Tremor is designed for high volume messaging environments. Using proactive rate limiting and a novel algorithm to handle back-propagation, Tremor optimizes back-pressure handling at capacity up to 10x more efficiently than alternatives such as Logstash and Telegraf."),(0,o.kt)("li",{parentName:"ul"},"In-flight Redeployment - Tremor can be reconfigured via its API to allow workload migration and reconfiguration without redeployment."),(0,o.kt)("li",{parentName:"ul"},"Event processing - Tremor's primary goal is to operate as an Extract, Transform, and Loading (ETL) tool. While Tremor adopts principles from Distributed Event Based Systems (DEBS), Event Stream Processor (ESP) and Complex Event Processing (CEP) infrastructures, it is by no means an exhaustive system that encompasses all the aforementioned communities' features and requirements.")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Tremor Stats",src:r(53452).Z})),(0,o.kt)("h2",{id:"tremor-urls"},"Tremor URLs"),(0,o.kt)("p",null,"Since Tremor v0.4, all internal artefacts and running instances of ",(0,o.kt)("strong",{parentName:"p"},"onramps"),", ",(0,o.kt)("strong",{parentName:"p"},"offramps")," and ",(0,o.kt)("strong",{parentName:"p"},"pipelines")," are dynamically configurable. Connection with these artefacts and the Tremor API is facilitated through Tremor URLs:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Example URL"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"tremor://localhost:9898/")),(0,o.kt)("td",{parentName:"tr",align:null},"A local Tremor instance",(0,o.kt)("br",null),(0,o.kt)("em",{parentName:"td"}," Accessible on the local host",(0,o.kt)("br",null))," REST API on port 9898 of the local host")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"tremor:///")),(0,o.kt)("td",{parentName:"tr",align:null},"Returns the current Tremor instance")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"tremor:///pipeline")),(0,o.kt)("td",{parentName:"tr",align:null},"Returns a list of pipelines")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"tremor:///pipeline/pl_01")),(0,o.kt)("td",{parentName:"tr",align:null},"Returns a pipeline with identifier 'pl_01'")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"tremor:///onramp/on_1")),(0,o.kt)("td",{parentName:"tr",align:null},"Returns an onramp with identifier 'on_01'")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"tremor:///offramp/off_01")),(0,o.kt)("td",{parentName:"tr",align:null},"Returns an offramp with identifier 'off_01'")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"tremor:///binding/bn_01")),(0,o.kt)("td",{parentName:"tr",align:null},"A binding that connects two artefacts")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"tremor:///binding/bn_01/tl_01")),(0,o.kt)("td",{parentName:"tr",align:null},"An active instance of data exchange between two artefacts")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null}),(0,o.kt)("td",{parentName:"tr",align:null})))),(0,o.kt)("p",null,"The Tremor REST API and configuration file formats follow the same URL format."),(0,o.kt)("p",null,"The current configuration model uses a shorthand URL form. It discriminates artefacts by type, so it is often sufficient to infer the ",(0,o.kt)("inlineCode",{parentName:"p"},"tremor:///{artefact-kind}")," component when specifying configuring artefacts."),(0,o.kt)("p",null,"For bindings, full URL path components are needed (ie.:",(0,o.kt)("inlineCode",{parentName:"p"},"/pipeline/01"),")."),(0,o.kt)("h2",{id:"runtime-model"},"Runtime Model"),(0,o.kt)("p",null,"Tremor's runtime model is composed of tasks that communicate via queues managed through Tremor's REST API. A task is spawned per onramp, offramp, and pipeline."),(0,o.kt)("p",null,"Tremor uses an async task model on top of the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/stjepang/smol"},"smol runtime")," and\n",(0,o.kt)("a",{parentName:"p",href:"https://async.rs/"},"async-rs"),"."),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"The Processing model will likely evolve over time alongside concurrency, threading, async and other primitives available in the rust ecosystem."))),(0,o.kt)("h2",{id:"event-ordering"},"Event Ordering"),(0,o.kt)("p",null,"Events flow from onramps (sources), through pipelines (connectors) that ingest them into the system, to offramps (sinks) that push them to external systems."),(0,o.kt)("p",null,"Tremor imposes causal event ordering over ingested events and processes events deterministically, although, given its nature as a distributed system, it cannot impose a total ordering over all ingested events."),(0,o.kt)("p",null,"Events flowing into Tremor from multiple onramps and multiple clients are considered independent. However, events sent by a ",(0,o.kt)("em",{parentName:"p"},"specific")," client through a ",(0,o.kt)("em",{parentName:"p"},"specific")," onramp into a ",(0,o.kt)("em",{parentName:"p"},"passthrough")," pipeline will flow through Tremor in their ",(0,o.kt)("em",{parentName:"p"},"origin")," order and be passed to offramps in the same ",(0,o.kt)("em",{parentName:"p"},"origin")," order. Requests from multiple independent sources over the same pipeline may arbitrarily interleave, but will not re-order."),(0,o.kt)("p",null,"In pipelines, events are processed in depth first order. In cases where Tremor operators have no intrinsic ordering (such as a branch split), Tremor internally ",(0,o.kt)("em",{parentName:"p"},"imposes")," an order."),(0,o.kt)("p",null,"Operator's may reorder events. For example, a windowed operator might batch multiple events into a single batch. An iterator could then operate on the batch and forward the events in an order that is the reverse of the original ingested order."),(0,o.kt)("p",null,"It is important to remember that Tremor itself does not re-order events - the order they are processed in is strictly deterministic."),(0,o.kt)("h2",{id:"pipeline-model"},"Pipeline Model"),(0,o.kt)("p",null,"The core processing model of Tremor is based on a directed-acyclic-graph based dataflow model."),(0,o.kt)("p",null,"Tremor pipelines are a graph of vertices (operators) with directed edges (connections) between operators in the graph."),(0,o.kt)("p",null,"Events from the outside world in a Tremor pipeline can only flow in one direction from input operators (connecting the pipeline to onramps) to output operators (connecting the pipeline to offramps)."),(0,o.kt)("p",null,"Operators process events and may produce ",(0,o.kt)("strong",{parentName:"p"},"zero to multiple")," output events for each event processed. As the building block of Tremor's processing logic, operators are designed for extension."),(0,o.kt)("p",null,"Tremor pipelines are able to process three types of events:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Data-flow"),(0,o.kt)("li",{parentName:"ul"},"Signal-flow"),(0,o.kt)("li",{parentName:"ul"},"Contra-flow")),(0,o.kt)("h3",{id:"data-flow"},"Data Flow"),(0,o.kt)("p",null,"Data flow constitute the majority of events that flow through Tremor's pipelines."),(0,o.kt)("p",null,"These events that carry transactional data are ingested via onramps from external upstream systems, processed through pipelines, then pushed via offramps to external dowstream systems."),(0,o.kt)("h3",{id:"signal-flow"},"Signal Flow"),(0,o.kt)("p",null,"Signal flow events are hidden from pipeline authors, but visible to onramp, offramp and operator developers. They are synthetic events generated by the tremor-runtime system that can be used by operators for advanced event handling purposes."),(0,o.kt)("h3",{id:"contraflow"},"Contraflow"),(0,o.kt)("p",null,"Contraflow events are sythentic events delivered under conditions caused by processing events already in a Tremor system. Tremor handles back-pressure events by exploiting contraflow."),(0,o.kt)("p",null,"The asynchronous nature of distributed event-based systems causes complications when resolving back-propogation issues. Tremor employs a novel algorithm to handle back-pressure and other events that propagate ",(0,o.kt)("em",{parentName:"p"},"backwards")," through a pipeline."),(0,o.kt)("p",null,"Pipelines are directed-acyclic-graphs (DAGs), so how do we back-propagate events without introducing cycles?"),(0,o.kt)("p",null,"Givens:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"There can be no cycles in a DAG."),(0,o.kt)("li",{parentName:"ul"},"DAGS are traversed in depth-first-search (DFS) order."),(0,o.kt)("li",{parentName:"ul"},"There can be no cycles in a DAG traversed in reverse-DFS order.")),(0,o.kt)("p",null,"The proposed solution:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"If we join a DAG ",(0,o.kt)("em",{parentName:"li"},"d")," with its mirrored (reversed) DAG ",(0,o.kt)("em",{parentName:"li"},"d'"),", we get another DAG where:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Every output in ",(0,o.kt)("em",{parentName:"li"},"d")," propogates events in ",(0,o.kt)("em",{parentName:"li"},"d'")," without cycles through its ",(0,o.kt)("em",{parentName:"li"},"d'")," mirrored input."),(0,o.kt)("li",{parentName:"ul"},"Branches in ",(0,o.kt)("em",{parentName:"li"},"d")," become combinators in ",(0,o.kt)("em",{parentName:"li"},"d'"),"."),(0,o.kt)("li",{parentName:"ul"},"Combinators in ",(0,o.kt)("em",{parentName:"li"},"d")," become branches in ",(0,o.kt)("em",{parentName:"li"},"d'"),"."),(0,o.kt)("li",{parentName:"ul"},"Any back-pressure detected in the processing of existing events can result in a synthetic signaling event injected into the reverse-DAG."))),(0,o.kt)("li",{parentName:"ul"},"The output-input pair at the heart of contraflow is called the 'pivot point'."),(0,o.kt)("li",{parentName:"ul"},"Injected events are called 'contraflow' because they move ",(0,o.kt)("em",{parentName:"li"},"backwards")," against the primary data flow.")),(0,o.kt)("p",null,"Result:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The cost of not injecting a contraflow event is zero."),(0,o.kt)("li",{parentName:"ul"},"The cost of an injected contraflow event, in Tremor, is minimized through pruning. For example, operators that are not contraflow aware do not receive or process contraflow events (Tremor optimizes for this case).")),(0,o.kt)("p",null,"There are other alternatives to handle back-pressure (such as those utilized by Spark, Storm, Hazelcast Jet, etc), however, Contraflow provides a much simpler solution than all other reasonable mechanisms with far fewer negative side-effects. Contraflow allows the Tremor project to provide users a tool to develop verifiable systems while undertaking much of the work needed to produce a lasting solution."),(0,o.kt)("h2",{id:"guaranteed-delivery"},"Guaranteed Delivery"),(0,o.kt)("p",null,"Tremor supports guaranteed delivery as long as both onramps and offramps support it. For onramps that do not provide natural support, the ",(0,o.kt)("a",{parentName:"p",href:"/docs/next/scripting/tremor-query/operators#qos::wal"},"qos::wal")," can be used to introduce a layer of guaranteed delivery."),(0,o.kt)("p",null,"Each event has a monotonic growing ID. Once an event ID is acknowledged\nas delivered, so are all other events with lower Id values. If an event ID\nis marked as failed to deliver, all events up to its ID value will be redeployed."),(0,o.kt)("h2",{id:"runtime-facilities"},"Runtime Facilities"),(0,o.kt)("p",null,"Tremor's runtime is composed of multiple facilities that work together to provide service."),(0,o.kt)("h3",{id:"conductors"},"Conductors"),(0,o.kt)("p",null,"Tremor uses a REST-based API that allows its operators to manage the lifecycle of onramps, offramps and pipelines deployed into a Tremor based system."),(0,o.kt)("p",null,"The set of facilities in the runtime that are related to service lifecycle, activation, and management are  referred to collectively as the Tremor conductor or Tremor control plane."),(0,o.kt)("p",null,"Operators can conduct up to multiple Tremor servers through its REST based API."),(0,o.kt)("p",null,"The API in turn interfaces with registry and repository facilities. Tremor distinguishes between artefacts and instances. Artefacts have no runtime overhead."),(0,o.kt)("p",null,"Artefacts in Tremor are declarative specifications of:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Onramps - a specific configuration of a supported onramp type"),(0,o.kt)("li",{parentName:"ul"},"Offramps - a specific configuration of a supported offramp type"),(0,o.kt)("li",{parentName:"ul"},"Pipelines - a specific configuration of a pipeline graph"),(0,o.kt)("li",{parentName:"ul"},"Bindings - a specefic configuration of how all other artefacts should be connected")),(0,o.kt)("p",null,"Artefacts can be thought of as analagous to code. They are a set of instructions, rules or configurations. As such, they are registered with Tremor via its API and stored in Tremor's artefact repository."),(0,o.kt)("p",null,"Deployment in Tremor is achieved through a mapping artefact. The mapping artefact specifies how artefacts should be deployed into one or many runtime instances, activated, and connected to live instances of onramps or offramps."),(0,o.kt)("p",null,"In Tremor, publishing a mapping results in instances being deployed. By unpublishing or deleting a mapping, instances are undeployed."),(0,o.kt)("h3",{id:"metrics"},"Metrics"),(0,o.kt)("p",null,"Metrics in Tremor are implemented as a pipeline and deployed during startup. They are built-in and cannot be undeployed."),(0,o.kt)("p",null,"Operators are able to attach offramps to the metrics service to distribute metrics to external systems, such as InfluxDB or Kafka."),(0,o.kt)("h2",{id:"data-model"},"Data Model"),(0,o.kt)("p",null,"Tremor supports unstructured data which can be in the form of raw binary, JSON, MsgPack, Influx or other structures."),(0,o.kt)("p",null,"Data can be ingested into a Tremor pipeline in any ",(0,o.kt)("strong",{parentName:"p"},"supported")," format."),(0,o.kt)("p",null,"Tremor pipeline operators will assume ",(0,o.kt)("em",{parentName:"p"},"some")," structure. For hierarchic or nested formats such as JSON and MsgPack, Tremor uses ",(0,o.kt)("inlineCode",{parentName:"p"},"serde")," serialisation and deserialisation capabilities."),(0,o.kt)("p",null,"Therefore, the ",(0,o.kt)("em",{parentName:"p"},"in-memory")," format for ",(0,o.kt)("em",{parentName:"p"},"JSON-like")," data in Tremor is effectively a ",(0,o.kt)("inlineCode",{parentName:"p"},"simd_json::Value"),". This provides the advantage of allowing Tremor-script to work with YAML, JSON or MsgPack data with no changes or considerations in the Tremor-script based on the origin data's format."),(0,o.kt)("p",null,"For line-oriented formats such as the Influx Line Protocol or GELF, they are typically transformed into Tremor's in-memory format (currently based on ",(0,o.kt)("inlineCode",{parentName:"p"},"serde"),")."),(0,o.kt)("p",null,"For raw binary or other data formats, Tremor provides a growing set of codecs that convert external data into Tremor in-memory form or vice-versa."),(0,o.kt)("p",null,"In general, operators and developers should ",(0,o.kt)("em",{parentName:"p"},"minimize")," the number of encoding/decoding steps required for the transit of data through Tremor or between Tremor instances."),(0,o.kt)("p",null,"Since the major overhead in most Tremor systems is encoding and decoding and JSON is the dominant data format, we ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/simd-lite/simdjson-rs"},"ported")," ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/lemire/simdjson"},"simd-json")," to reduce the cost of encoding and decoding significantly compared to other JSON implementations in Rust."),(0,o.kt)("h3",{id:"distribution-model"},"Distribution Model"),(0,o.kt)("p",null,"Tremor does not yet have an out-of-the-box network protocol. A native Tremor protocol is planned for development in the immediate/mid-term."),(0,o.kt)("p",null,"As such, Tremor's distribution model is currently limited to the set of available onramp and offramp connectors."),(0,o.kt)("p",null,"However, the websocket ",(0,o.kt)("a",{parentName:"p",href:"/docs/next/artefacts/onramps#ws"},"onramp")," and ",(0,o.kt)("a",{parentName:"p",href:"/docs/next/artefacts/offramps#ws"},"offramp")," can be used for Tremor to Tremor communication."),(0,o.kt)("h3",{id:"clientserver"},"Client/Server"),(0,o.kt)("p",null,"Tremor, is currently a client-server system. It uses a synchronous blocking RESTful API over HTTP to conduct operations related to its high throughput and high performance pipeline-oriented data plane."),(0,o.kt)("p",null,"In the near future we plan on developing clustering capability, making Tremor a fully distributed system. Tremor will still support client-server deployments through a standalone mode of clustered operation, which can be thought of as a cluster of one."))}c.isMDXComponent=!0},53452:function(e,t,r){t.Z=r.p+"assets/images/stats-80f06cc6dcbebcdda88dbc29ac701b66.png"}}]);